"""Tool for performing malware analysis using external services.

This tool interfaces with VirusTotal and Hybrid Analysis APIs to analyze
suspicious files or hashes for malicious behaviors and patterns.
"""

import hashlib
import logging
import os
import re
from pathlib import Path
from typing import Any, Dict, Literal, Optional, Type

import requests
import yaml
from crewai.tools import BaseTool
from dotenv import load_dotenv
from pydantic import BaseModel, ConfigDict, Field, field_validator

logger = logging.getLogger(__name__)

# Load environment variables from .env file if it exists
load_dotenv()

# Constants
SHA256_REGEX = re.compile(r"^[a-fA-F0-9]{64}$")
MD5_REGEX = re.compile(r"^[a-fA-F0-9]{32}$")
SHA1_REGEX = re.compile(r"^[a-fA-F0-9]{40}$")
TOOL_CONFIG_PATH = Path(__file__).parent / "tool.yaml"


# --- Pydantic Input Model ---
class MalwareAnalysisInput(BaseModel):
    """Input model for MalwareAnalysisTool."""

    model_config = ConfigDict(extra="forbid")  # Disallow extra fields

    content_or_path: str = Field(
        description="The file path or hash (SHA256, MD5, SHA1) to analyze."
    )
    analysis_type: Literal["static", "dynamic", "auto"] = Field(
        default="auto",
        description=(
            "Specify the type of analysis: 'static' (hash lookup), "
            "'dynamic' (file submission for sandbox), or 'auto' (detect hash/file)."
        ),
    )

    @field_validator("content_or_path")
    @classmethod
    def validate_content_or_path(cls, v: str) -> str:
        if not v:
            raise ValueError("Input 'content_or_path' cannot be empty.")
        # Basic check - more specific validation happens in the tool logic
        return v.strip()


# --- Tool Implementation ---
class MalwareAnalysisTool(BaseTool):
    """Tool for analyzing suspicious files/hashes via VirusTotal & Hybrid Analysis.

    Requires API keys for VirusTotal and Hybrid Analysis, which can be provided
    via environment variables (VIRUSTOTAL_API_KEY, HYBRID_ANALYSIS_API_KEY) or
    explicitly in the tool configuration.

    Supports static analysis (hash lookups) and dynamic analysis (file submission).
    """

    name: str = "malware_analysis_tool"
    description: str = (
        "Analyzes suspicious files or hashes using VirusTotal and Hybrid Analysis APIs. "
        "Input: 'content_or_path' (file path or hash string), 'analysis_type' ('static', 'dynamic', 'auto')."
    )
    args_schema: Type[BaseModel] = MalwareAnalysisInput
    tool_config: Optional[Dict[str, Any]] = None
    virustotal_api_key: Optional[str] = None
    hybrid_analysis_api_key: Optional[str] = None
    vt_api_url: str = "https://www.virustotal.com/api/v3"
    ha_api_url: str = "https://www.hybrid-analysis.com/api/v2"
    request_timeout: int = 60

    def __init__(self, **kwargs):
        """Initialize the tool, load config, and get API keys."""
        super().__init__(**kwargs)
        self.tool_config = self._get_config()
        self.virustotal_api_key = self._get_api_key(
            "virustotal_api_key", "VIRUSTOTAL_API_KEY"
        )
        self.hybrid_analysis_api_key = self._get_api_key(
            "hybrid_analysis_api_key", "HYBRID_ANALYSIS_API_KEY"
        )
        self.vt_api_url = (
            self.tool_config.get("configuration", {})
            .get("parameters", {})
            .get("vt_api_url", {})
            .get("default", self.vt_api_url)
        )
        self.ha_api_url = (
            self.tool_config.get("configuration", {})
            .get("parameters", {})
            .get("ha_api_url", {})
            .get("default", self.ha_api_url)
        )
        self.request_timeout = (
            self.tool_config.get("configuration", {})
            .get("parameters", {})
            .get("request_timeout", {})
            .get("default", self.request_timeout)
        )

        if not self.virustotal_api_key:
            logger.warning(
                "VirusTotal API key not found. VirusTotal analysis will be skipped."
            )
        if not self.hybrid_analysis_api_key:
            logger.warning(
                "Hybrid Analysis API key not found. Hybrid Analysis will be skipped."
            )

    def _get_config(self) -> Optional[Dict[str, Any]]:
        """Load the tool's configuration from tool.yaml."""
        if not TOOL_CONFIG_PATH.exists():
            logger.error(f"Tool configuration file not found at {TOOL_CONFIG_PATH}")
            return None
        try:
            with open(TOOL_CONFIG_PATH, "r") as f:
                config = yaml.safe_load(f)
                logger.info(f"Successfully loaded tool config from {TOOL_CONFIG_PATH}")
                return config
        except yaml.YAMLError as e:
            logger.error(
                f"Error parsing tool configuration file {TOOL_CONFIG_PATH}: {e}"
            )
            return None
        except Exception as e:
            logger.error(f"Unexpected error loading tool config: {e}")
            return None

    def _get_api_key(self, config_key: str, env_var: str) -> Optional[str]:
        """Get API key from environment variable first, then config file."""
        api_key = os.getenv(env_var)
        if api_key:
            logger.debug(f"Found API key in environment variable {env_var}")
            return api_key

        if self.tool_config:
            config_params = self.tool_config.get("configuration", {}).get(
                "parameters", {}
            )
            api_key = config_params.get(config_key, {}).get(
                "default"
            )  # Check default in YAML
            if (
                api_key
            ):  # Note: YAML default is usually null, so check env first is better
                logger.debug(f"Using API key from tool config default for {config_key}")
                return api_key  # Return explicit default from config ONLY if env var is missing

        logger.warning(
            f"API key not found in environment variable {env_var} or tool config {config_key}."
        )
        return None

    def _is_hash(self, value: str) -> Optional[Literal["sha256", "md5", "sha1"]]:
        """Check if the input string matches known hash formats."""
        if SHA256_REGEX.match(value):
            return "sha256"
        if MD5_REGEX.match(value):
            return "md5"
        if SHA1_REGEX.match(value):
            return "sha1"
        return None

    def _get_file_hash(self, file_path: str) -> Optional[str]:
        """Calculate the SHA256 hash of a file."""
        try:
            hasher = hashlib.sha256()
            with open(file_path, "rb") as file:
                while chunk := file.read(8192):
                    hasher.update(chunk)
            return hasher.hexdigest()
        except FileNotFoundError:
            logger.error(f"File not found for hashing: {file_path}")
            return None
        except IOError as e:
            logger.error(f"Error reading file {file_path} for hashing: {e}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error hashing file {file_path}: {e}")
            return None

    def _run(self, **kwargs) -> str:
        """Execute malware analysis based on validated input arguments."""
        try:
            input_data = MalwareAnalysisInput(**kwargs)
        except Exception as e:
            logger.error(f"Input validation failed: {e}")
            return f"Error: Input validation failed: {e}"

        content_or_path = input_data.content_or_path
        analysis_type = input_data.analysis_type

        target_is_hash = self._is_hash(content_or_path)
        target_is_file = Path(content_or_path).is_file()  # Basic file check

        results = {"virustotal": "Skipped", "hybrid_analysis": "Skipped"}
        target_description = ""
        file_hash = None

        # Check if tool is properly configured
        if not self.tool_config:
            logger.error("Tool is not properly configured. Missing tool.yaml file.")
            return "Error: Malware Analysis Tool is not properly configured. Missing tool.yaml configuration file."
            
        # Check for API keys
        if not self.virustotal_api_key and not self.hybrid_analysis_api_key:
            logger.error("No API keys available for VirusTotal or Hybrid Analysis.")
            return "Error: Neither VirusTotal nor Hybrid Analysis API keys are configured. At least one is required for analysis."

        if analysis_type == "auto":
            if target_is_hash:
                analysis_type = "static"
            elif target_is_file:
                # Auto defaults to static hash check first if it's a file
                analysis_type = "static"
                file_hash = self._get_file_hash(content_or_path)
                if not file_hash:
                    return (
                        f"Error: Could not calculate hash for file: {content_or_path}"
                    )
                target_description = (
                    f"file path '{content_or_path}' (hash: {file_hash})"
                )
            else:
                # If it's not a hash and not a file, it's likely invalid input
                return f"Error: Input '{content_or_path}' is not a recognized hash or a valid file path."

        # --- Static Analysis (Hash Lookup) ---
        if analysis_type == "static":
            if target_is_hash:
                target_hash = content_or_path
                target_description = f"hash ({target_is_hash}) '{target_hash}'"
            elif target_is_file:
                if not file_hash:  # Calculate hash if not done in auto mode
                    file_hash = self._get_file_hash(content_or_path)
                if not file_hash:
                    return (
                        f"Error: Could not calculate hash for file: {content_or_path}"
                    )
                target_hash = file_hash
                target_description = (
                    f"file path '{content_or_path}' (hash: {target_hash})"
                )
            else:
                return f"Error: Static analysis requires a valid hash or file path. Input '{content_or_path}' is neither."

            logger.info(
                f"Performing static analysis (hash lookup) for {target_description}"
            )
            if self.virustotal_api_key:
                results["virustotal"] = self._call_virustotal_api(
                    "get", f"/files/{target_hash}"
                )
            if self.hybrid_analysis_api_key:
                # HA quick scan lookup uses POST with hash
                results["hybrid_analysis"] = self._call_hybrid_analysis_api(
                    "post", "/search/hash", data={"hash": target_hash}
                )

        # --- Dynamic Analysis (File Submission) ---
        elif analysis_type == "dynamic":
            if not target_is_file:
                return f"Error: Dynamic analysis requires a valid file path. Input '{content_or_path}' is not a file."

            target_description = f"file path '{content_or_path}'"
            logger.info(
                f"Performing dynamic analysis (submission) for {target_description}"
            )

            # Dynamic analysis usually involves file submission
            # Placeholder: Implement actual file submission logic here
            if self.virustotal_api_key:
                # VT file submission is more complex, requires multipart upload
                # results["virustotal"] = self._submit_file_to_vt(content_or_path)
                results["virustotal"] = (
                    "Dynamic analysis (file submission) for VirusTotal not yet implemented."
                )
            if self.hybrid_analysis_api_key:
                # results["hybrid_analysis"] = self._submit_file_to_ha(content_or_path)
                results["hybrid_analysis"] = (
                    "Dynamic analysis (file submission) for Hybrid Analysis not yet implemented."
                )
        else:
            return f"Error: Unknown analysis type '{analysis_type}'. Use 'static', 'dynamic', or 'auto'."

        # --- Format and Return Results ---
        # Use triple quotes for clean multi-line f-string definition
        report = f"""### Malware Analysis Report

**Target:** {target_description}
**Analysis Type:** {analysis_type}

"""
        report += f"""**VirusTotal Results:**
```json
{results['virustotal']}
```

"""
        report += f"""**Hybrid Analysis Results:**
```json
{results['hybrid_analysis']}
```
"""

        return report

    # --- API Interaction Placeholders ---
    # These need to be implemented with actual requests logic, error handling, etc.

    def _call_virustotal_api(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        files: Optional[Dict] = None,
    ) -> str:
        """Placeholder for making calls to the VirusTotal API."""
        if not self.virustotal_api_key:
            return "Skipped: VirusTotal API key not configured."

        url = f"{self.vt_api_url}{endpoint}"
        headers = {"x-apikey": self.virustotal_api_key, "Accept": "application/json"}
        logger.debug(f"Calling VirusTotal API: {method.upper()} {url}")

        try:
            response = requests.request(
                method,
                url,
                headers=headers,
                params=params,
                json=(
                    data if method.lower() != "get" and files is None else None
                ),  # Use json for post/put/patch if not file upload
                data=(
                    data if method.lower() == "get" or files is not None else None
                ),  # Use data for get or file upload
                files=files,
                timeout=self.request_timeout,
            )
            response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
            logger.info(
                f"VirusTotal API call successful ({response.status_code}) for {endpoint}"
            )
            return response.text  # Return raw text for now, parsing needed
        except requests.exceptions.RequestException as e:
            logger.error(f"VirusTotal API request failed: {e}")
            status_code = e.response.status_code if e.response is not None else "N/A"
            error_content = (
                e.response.text if e.response is not None else "No response content"
            )
            return f"Error: VirusTotal API request failed (Status: {status_code}): {error_content}"
        except Exception as e:
            logger.error(f"Unexpected error calling VirusTotal API: {e}")
            return f"Error: Unexpected error during VirusTotal API call: {e}"

    def _call_hybrid_analysis_api(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        files: Optional[Dict] = None,
    ) -> str:
        """Placeholder for making calls to the Hybrid Analysis API."""
        if not self.hybrid_analysis_api_key:
            return "Skipped: Hybrid Analysis API key not configured."

        url = f"{self.ha_api_url}{endpoint}"
        headers = {
            "api-key": self.hybrid_analysis_api_key,
            "User-Agent": "CrewAI MalwareAnalysisTool/1.0",  # HA requires User-Agent
            "Accept": "application/json",
        }
        logger.debug(f"Calling Hybrid Analysis API: {method.upper()} {url}")

        try:
            response = requests.request(
                method,
                url,
                headers=headers,
                params=params,
                data=data,  # HA typically uses form-data or query params
                files=files,
                timeout=self.request_timeout,
            )
            response.raise_for_status()
            logger.info(
                f"Hybrid Analysis API call successful ({response.status_code}) for {endpoint}"
            )
            return response.text  # Return raw text for now, parsing needed
        except requests.exceptions.RequestException as e:
            logger.error(f"Hybrid Analysis API request failed: {e}")
            status_code = e.response.status_code if e.response is not None else "N/A"
            error_content = (
                e.response.text if e.response is not None else "No response content"
            )
            return f"Error: Hybrid Analysis API request failed (Status: {status_code}): {error_content}"
        except Exception as e:
            logger.error(f"Unexpected error calling Hybrid Analysis API: {e}")
            return f"Error: Unexpected error during Hybrid Analysis API call: {e}"

    # Note: _arun is intentionally omitted for brevity.
    # If async operation is needed, implement _arun to call async versions
    # of the API interaction methods using libraries like httpx.
